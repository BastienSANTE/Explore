%%%====================%%%
%%% CONFIGURATION FILE %%%
%%%====================%%%

%%% VARIABLE DECLARATIONS
%%% These variables are font-wide, and serve to define
%%% parameters in each glyph
%path skl[];
pair ikp[]; % Coordinates to define inktraps
pair sfp[]; % Coordinates to define serif positions
pair dot[];

%%% PEN STROKE SETTINGS
%%% These settings define the main "boldness" of the glyphs.
BAR:=   .96pt; % Normal horizontal stroke width
BAR_C:= .96pt; % "Counterpart", to use in high-contrast fonts, and avoid modifying TH or TV. For the classic font, keep BAR_C = BAR;

STEM:=   1.28pt; % Normal vertical stroke width
STEM_C:= 1.28pt; % Same rule as NH and NH_C

BAR_TERM  := BAR * 0.8;
STEM_TERM := STEM * 0.8;
BAR_JOINT := BAR * 0.67;
STEM_JOINT:= STEM * 0.67;
BAR_THIN  := BAR * 0.5;
STEM_THIN := STEM * 0.5;
BAR_FINE  := BAR * 0.25;
STEM_FINE := STEM * 0.25;

%%% ESSENTIAL METRICS
STRETCH:= 1.05;  % Font width setting, to create "condensed" or "expanded" versions.
EM_H:= 8pt#;     % height of the bounding box of the fontx
DEPTH:= 2.24pt#; % Size of the bounding box's descender.
% The total of em_h and depth are equal to 10.24, in order to match the 1024 unit TrueType convetion.
CAP_H:= 7pt;                 % Height of standard uppercase glyphs
X_H:= 5.2pt;                 % Height of standard lowercase glyphs
BASELINE:= 0pt;                   % Self-explanatory
OVERSHOOT:= 0.08pt;               % Height compensation for glyphs with rounded tops
CAP_TOP = CAP_H + OVERSHOOT; % Top of uppercase glyphs with oversoot
CAP_BOTTOM = BASELINE - OVERSHOOT;% Lowest point of uppercase glyphs with overshoot
DESCENDER = -1.92pt;              % Actual position of the descender
X_TOP:= X_H + OVERSHOOT;          % Top of rounded lowercase glyphs

%%% CURVATURE
TSN:= .9; % Average tension of curvature
APERTURE:= .19; % Average aperture of glyphs, based on height;
APERTURE_ANGLE:= 40;
INV_APERTURE_ANGLE:= 180 + APERTURE_ANGLE;
ARCHCOEF:= 0.6;
ARCHCORR:= 0.2pt;

%%% SERIFS
boolean SERIF;
SERIF:= false;
SERIF_LENGTH#:= .7pt#;
SERIF_THICKNESS:= BAR;
TERM_LENGTH#:= 1pt#;

SERIFL:= SERIF_LENGTH;

%%% MONOSPACE METRICS
boolean MONOSPACE;
MONOSPACE = false;
MONO_WIDTH#:= 6pt#;

%%% SIDEBEARINGS & BASIC KERNING
CURVE_BEARING:=.56pt; % Average sidebearing for glyphs with curved edges
LINE_BEARING:= .8pt;  % Average sidebearing for glyphs with straight stems
STEM_BEARING:= .64pt; % Average sidebearing for B, D, P, Q...
LEG_BEARING:= .64pt;
OBLIQUE_BEARING:= .36pt;
MONO_CURVE_BEARING:= .56pt;
MONO_LINE_BEARING:= .8pt;

%%% DIACRITICS & ACCENTS
ACC_YOFFSET:= 1.5pt; % Offset between the top of the lowercase glyphs and diacritics. 
DOTSIZE:= STEM * 1.25;  % Diameter of the standard dot above i, ï, ÿ...

%%% ALTERNATE GLYPHS
% Some fonts have an option to enable "alternate" styles for certain glyphs,
% namely A, G, K, S, Z, etc. Modern type engines allow to select these alte-
% rnate glyphs for style reasons, to add flair.

% Variables which are not of NUMERIC type must have a type declaration.
% See the METAFONTbook, Chapter 7 for more information.
boolean OLDSTYLE;
OLDSTYLE = false;

%def midpoint(expr a)

%def makeserif(expr origin)

% NEWCHAR() : Creates a new glyph, with all definitions already made
def export_setup =
  outputtemplate := "%c.svg";
  outputformat := "svg";
enddef;


def newchar(expr code, width, serifc) =
  mode_setup;

  PROP_WIDTH:= width;
  SERIF_C:= serifc;

  if MONOSPACE = true:
    WIDTH:= MONO_WIDTH#;
    LINE_BEARING:= MONO_LINE_BEARING;
    CURVE_BEARING:= MONO_CURVE_BEARING;
  else:
  
    if SERIF = true:
      WIDTH:= PROP_WIDTH * STRETCH;
    else:
      WIDTH:= PROP_WIDTH * STRETCH;
    fi
  fi

  %input ../Config/ExploreSansCFG.mf;

  define_pixels(SERIF_LENGTH);
  define_pixels(TERM_LENGTH);
  beginchar(code, WIDTH, EM_H, DEPTH);
enddef;


def makeserif(suffix $)(expr origin, h_expand, v_expand) =
  z$a = origin;
  z$b = origin shifted(h_expand, 0);
  z$c = origin shifted(h_expand, v_expand);
  z$d = origin shifted(0, v_expand);

  fill z$a -- z$b -- z$c -- z$d -- cycle;
  labels($a, $b, $c, $d);
enddef;

numeric PI; PI:= 3.141593;

def dotproduct(expr sp, ep) =
  ((xpart sp / 1pt) * (xpart ep / 1pt)) + ((ypart sp / 1pt) * (ypart ep / 1pt))
enddef;

def magnitude(expr p) =
  sqrt(((xpart p / 1pt) * (xpart p / 1pt)) + ((ypart p / 1pt) * (ypart p / 1pt));
enddef;

def radtodeg(expr ang) =
  ang * 180/PI;
enddef;

  


%%% SHORTCUTS & SNIPPETS
def lt:= left enddef;
def rt:= right enddef;
def dn:= down enddef;
def daa:= dir APERTURE_ANGLE enddef;
def naa:= dir -APERTURE_ANGLE enddef;
def dia:= dir INV_APERTURE_ANGLE enddef;
def nia:= dir -INV_APERTURE_ANGLE enddef;


def tsn = tension TSN enddef;
def invtsn = tension (1 / TSN) enddef;

  

  
