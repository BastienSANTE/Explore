%%%====================%%%
%%% CONFIGURATION FILE %%%
%%%====================%%%

%%% VARIABLE DECLARATIONS
%%% These variables are font-wide, and serve to define
%%% parameters in each glyph
%path skl[];

pair ikp[]; % Coordinates to define inktraps
pair sfp[]; % Coordinates to define serif positions
pair dot[];

%%% PEN STROKE SETTINGS
%%% These settings define the main "boldness" of the glyphs.
BAR:=   .96pt; % Normal horizontal stroke width
BAR_C:= .96pt; % "Counterpart", to use in high-contrast fonts, and avoid modifying TH or TV. For the classic font, keep BAR_C = BAR.

STEM:=   1.28pt; % Normal vertical stroke width
STEM_C:= 1.28pt; % Same rule as NH and NH_C

BAR_TERM  := BAR * 0.8;
STEM_TERM := STEM * 0.8;
BAR_JOINT := BAR * 0.67;
STEM_JOINT:= STEM * 0.67;
BAR_THIN  := BAR * 0.5;
STEM_THIN := STEM * 0.5;
BAR_FINE  := BAR * 0.25;
STEM_FINE := STEM * 0.25;

%%% ESSENTIAL METRICS
STRETCH:= 1.05;  % Font width setting, to create "condensed" or "expanded" versions.
EM_H:= 8pt#;     % height of the bounding box of the fontx
DEPTH:= 2.24pt#; % Size of the bounding box's descender.
% The total of em_h and depth are equal to 10.24, in order to match the 1024 unit TrueType convetion.
CAP_H:= 7pt;                 % Height of standard uppercase glyphs
X_H:= 5.2pt;                 % Height of standard lowercase glyphs
BASELINE:= 0pt;                   % Self-explanatory
OVERSHOOT:= 0.08pt;               % Height compensation for glyphs with rounded tops
CAP_TOP = CAP_H + OVERSHOOT; % Top of uppercase glyphs with oversoot
CAP_BOTTOM = BASELINE - OVERSHOOT;% Lowest point of uppercase glyphs with overshoot
DESCENDER = -1.92pt;              % Actual position of the descender
X_TOP:= X_H + OVERSHOOT;          % Top of rounded lowercase glyphs

%%% CURVATURE
TSN:= .9; % Average tension of curvature
APERTURE:= .2; % Average aperture of glyphs, based on height;
APERTURE_ANGLE:= 45;
INV_APERTURE_ANGLE:= 180 + APERTURE_ANGLE;
ARCHCOEF:= 0.6;
ARCHCORR:= 0.2pt;

%%% SERIFS
boolean SERIF;
SERIF:= false;
SERIF_LENGTH#:= .7pt#;
SERIF_THICKNESS:= BAR;
TERM_LENGTH#:= 1pt#;

SERIFL:= SERIF_LENGTH;

%%% MONOSPACE METRICS
boolean MONOSPACE;
MONOSPACE = false;
MONO_WIDTH#:= 6pt#;

%%% SIDEBEARINGS & BASIC KERNING
CURVE_BEARING:=.56pt; % Average sidebearing for glyphs with curved edges
LINE_BEARING:= .8pt;  % Average sidebearing for glyphs with straight stems
STEM_BEARING:= .64pt; % Average sidebearing for B, D, P, Q...
LEG_BEARING:= .64pt;
OBLIQUE_BEARING:= .36pt;
MONO_CURVE_BEARING:= .8pt;
MONO_LINE_BEARING:= .96pt;

%%% DIACRITICS & ACCENTS
ACC_YOFFSET:= 1.5pt; % Offset between the top of the lowercase glyphs and diacritics. 
DOTSIZE:= STEM * 1.25;  % Diameter of the standard dot above i, ï, ÿ...

%%% ALTERNATE GLYPHS
% Some fonts have an option to enable "alternate" styles for certain glyphs,
% namely A, G, K, S, Z, etc. Modern type engines allow to select these alte-
% rnate glyphs for style reasons, to add flair.

% Variables which are not of NUMERIC type must have a type declaration.
% See the METAFONTbook, Chapter 7 for more information.
boolean OLDSTYLE;
OLDSTYLE = false;

%%% INKTRAPS & OPTICAL CORRECTION
INKFAC:= 0.35; % "Inktrap factor" defines the relativ importance of inktraps
%def midpoint(expr a)

def BAR_ADJ(expr a, b) =
  BAR * acorr(a, b)
enddef;


def PT = 1pt enddef;

%def makeserif(expr origin)

% NEWCHAR() : Creates a new glyph, with all definitions already made
def export_setup =
  outputtemplate := "%c.svg";
  outputformat := "svg";
enddef;


def newchar(expr code, width, serifc) =
  mode_setup;

  PROP_WIDTH:= width;
  SERIF_C:= serifc;

  if MONOSPACE = true:
    WIDTH:= MONO_WIDTH#;
    LINE_BEARING:= MONO_LINE_BEARING;
    CURVE_BEARING:= MONO_CURVE_BEARING;
  else:
  
    if SERIF = true:
      WIDTH:= PROP_WIDTH * STRETCH;
    else:
      WIDTH:= PROP_WIDTH * STRETCH;
    fi
  fi

  %input ../Config/ExploreSansCFG.mf;

  define_pixels(SERIF_LENGTH);
  define_pixels(TERM_LENGTH);
  beginchar(code, WIDTH, EM_H, DEPTH);
enddef;


def makeserif(suffix $)(expr origin, h_expand, v_expand) =
  z$a = origin;
  z$b = origin shifted(h_expand, 0);
  z$c = origin shifted(h_expand, v_expand);
  z$d = origin shifted(0, v_expand);

  fill z$a -- z$b -- z$c -- z$d -- cycle;
  labels($a, $b, $c, $d);
enddef;

numeric PI; PI:= 3.141593;

primarydef w dprod z =
  (xpart w * ypart w) + (xpart z * ypart z)
enddef;

primarydef a cprod b =
  ((xpart a / PT) * (ypart b / PT)) - ((xpart b / PT) * (ypart a / PT))
enddef;

def tan(expr a, b) =
  ((ypart a - xpart b) / (xpart a - xpart b)) / PT 
enddef;

def atan(expr a, b) =
  1 / tan(a, b)
enddef;

def pmag expr p =
  (xpart p * xpart p) + (ypart p * ypart p)
enddef;

def corr(expr a, b) =
  sind(((a dprod b)/ PT) / ((pmag a) * (pmag b)) / PT)
enddef;
  
def acorr(expr a, b) =
  atan(a, b)
enddef;

%%% SHORTCUTS & SNIPPETS
def lt:= left enddef;
def rt:= right enddef;
def dn:= down enddef;
def daa:= dir APERTURE_ANGLE enddef;
def naa:= dir -APERTURE_ANGLE enddef;
def dia:= dir INV_APERTURE_ANGLE enddef;
def nia:= dir -INV_APERTURE_ANGLE enddef;

def tsn = tension TSN enddef;
def invtsn = tension (1 / TSN) enddef;

def BAR_ADJ(expr a, b) =
  BAR * acorr(a, b)
enddef;

def STEM_ADJ(expr a, b) =
  STEM * acorr(a, b)
    enddef;

  

  
